Symmetric encrytion:
Communication between two users that use a single key to encrypt and decrypt messages, encryption and decryption algorithms in this case can use something like XOR
where the key just specifies what bits to flip in the message

Asymmetric encryption:
Communication between two users that uses two keys for each user to encrypt and decrypt messages, one called a public key, and the other called a private key and they are
inverses of eachother meaning you can only use the other key to decrypt a message that was encrypted by one of the keys, works by the two users keep their private keys to
themselves and under no circumstances should they share this key, then the put their public key up in the public and the two users use the others public key to encrypt their
message and then send it, since only the owner of the private key is the only person that can decrypt these messages no third party can intercept and learn the details of the
message, then once the other user gets the message they can use their private key for decryption, this method can also be used to determine who the message comes from by
encrypting a message twice, once with the users private key, and another time with the receptients public key, and decrypted using the senders public key and the recepients
private key, encrypting with the private key before sending makes it so that only that specific user could have sent that message since only the owner has access to the private
key, so imitation is not possible using this method aswell. Downside of this type of encryption is the algorithm for encryption and decryption is more time consuming when
compared to the simple XOR algorithm present in symmetric encryption, and encryption and decryption algorithm for Asymmetric encryption would be...

End to End Encryption:
Encryption such that only the sender encrypts the message and only the reciever decrypts the message, meaning that the message is not intercepted and decrypted by a third party,
E2EE uses Asymmetric encryption as a means to achieve this

Diffie Hellman:
A method to solve the initial problem which is the sharing of keys between two communicating users without having the keys leak assuming there is not a secure channel, 
this can be done by sharing numbers called the generator on a unsecure channel and the two users generating their own private keys, then the public keys for the two users
are generated by combining their private keys with the generator and then publicizing those as well, then taking the other users public key and combining it with their own
private key and as a result both users get a key they can use for symmetric encryption, this is obviously a very dumbed down explanation of this process and does not go into
the mathematical details. An implimentation of this algorithm using math uses the multiplicative group of integers modulo p where this is a group with elements being integers
such that the group operator is normal multiplication modulo with the number p, there are some things we have to note about this group...

.first the elements of this group are all coprimes of p since if the numbers of this group isn't coprime with p then by the group operator those elements wouldn't have a 
inverse element with repect to the group operator (identity element of this group still being in this case 1), 

.second setting p to a prime number causes the order of this group to be p - 1 by calculation using the Euler's totient function (this should be obvious by observation 
though since modulo groups only contain integers from 0 to p - 1 and since p is prime 1 to p - 1 have to be coprime to p)

.third the existence of a generator of a group which is a subset of the elements of the group such that every element of the group can be generated by
combinations of elements of the subset and the group operator, in the context of the modulo groups and criptography we need to find a generator which is just a single integer
of the molulo group, this means that every other element is generated from it with the group operator (or in other terms g^a mod p = n for all n and for some integer a) 

Now we can get to the actual mathematical algorithm, first we put a very large prime number p on the unsecure channel for the 2 users to share, this number is very large so 
the modulo operator gives us plently of potential numbers and its prime so we can use the second point mentioned previously and we also put another number g on the unsecure 
channel which is a generator for the modulo group p, next the two users calculate their public keys by choosing random integers that are part of the modulo group p lets call 
them a and b for user 1 and user 2 respectively, these numbers are called the private keys and using these we can get the public keys by calculating A := g^a mod p for user 
1 and B := g^b mod p for user 2, then using this we can calculate a common secret (aka the key for symmetric encryption) by taking the other users public key, putting it to 
the power of our private key, then mod p, example for user 1 we take B^a mod p and user 2 we do A^b mod p and both of these we be the same value since....

B^a mod p = (g^b mod p)^a mod p = (g^b)^a mod p = g^ba mod p
A^b mod p = (g^a mod p)^b mod p = (g^a)^b mod p = g^ba mod p

Where properties of the modulo operator are used here (not 100% sure why these properties are true, did not do that much research here) and as a reult both numbers user 1 and
2 end up with end up being the same and can be used as a key for cryptography, note also now by the third point we have that this key can be any number between 1 and p - 1
so if we chose p to be an insanely large prime number the amount of possibilities for this value are so large that it would take an infesable amount of time to brute force
finding the key if an attacker chooses to do so, and also the attacker only has access to the following information, p, g, A := g^a mod p, and B := g^b mod p, for the attacker
to calculate the key they would need to get the private keys and the only way to get these keys through mathematics atleast would be through the equation for A and B and 
finding the value for g^a and g^b, but since mod just gives us the remainder and g^a and g^b have the potential to be >>>>> than p there would be to many possible values for
g^a and g^b and also this method would require an infessable amount of time aswell, and that sums up the mathematical (or atleast one implimentation) version of this algorithm.

Block cipher: an encryption algorithm that works only on consistent amounts of text, this means that if we have a block cipher of lets say 128 bits then that block cipher
will only be able to encrypt a message 128 bits at a time with a key, if the message is not divisible by 128 bits then padding of the message may be necessary

Stream cipher: an encrytion algorithm that works by taking plain text bit by bit (or byte by byte) and encoding it one bit (or byte) at a time using a key stream which
generates a random bit (or byte) for each plaintext bit/byte input and encrypts that to the ciphertext bit/byte

Block cipher Mode of operation: a block cipher takes as input a key, a message to encrypt, and a mode of operation which states how the block cipher will encrypt the message
if the message is not exactly equal to the block size













