Chapter 3
###########################################################################
This chapter of linkers and loaders goes over object files, what they are, and the different formats they come in depending on the host operating system, first we go over the
question of what is an object file? An object file is a file that is created from a compiler after the process of turning source code into machine code, they can be used in
combination with other object files to create an executable that can be loaded into the cpu to execute a series of instructions (called linkable, so .o files in linux for example),
they can be an executable themselves (called executable obviously, .exe files in windows for example, in linux executables don't really have a specific file extension), or they can be loaded into memory
as a library (called loadable, .so files in linux for example). The type of information an object file will contain depends on whether it is either linkable, loadable, or 
executable, and these different types are as follows...

. header information: overall information about the file itself, about sections in the file, size of certain sections, locations of certain symbols inside the file using
relocatable addressing (symbol table), creation date, stuff like that

. object code: executable machine code and data that was generated by the compiler

. relocation: places in the object code that needs fixups before that code can be actually executed, so for example resolving symbols that need to be resolved since their
definition is currently not present

. symbols: information on the symbols that are used in the file (symbols are any named objects that have a definition, can be a function, variable, or something else), this is
located inside the symbol table

. debugging information: pretty self explanitory what this means, this can range from being remembering the lines of code in the source file and their numbers to stuff like
symbol names

The amount of this information used in the object file depends on the type of object file it is that was mentioned before (that being linkable, executable, and loadable), for
example a linkable file will usually need symbols in the object code to be resolved since their definition is currently not available, so this information will be present 
inside of linkable files (so relocation information) and also information in general about all symbols so their definition can be used by other object files (so symbol 
information inside a symbol table). An executable will usually not need much symbol or relocation information inside it and will usually have its segments page aligned so that
its ready for execution. A loadable executable will consist of object code and also symbol information to allow for dynamic linking so other processes can use its definitions.
Now we go over some popular formats for object files that were used in the past and some that are still being currently used.
###########################################################################
Unix ELF:

ELF is still a format for object files that is still being used for linux operating systems to this day for object files, formerly unix systems used the a.out format for object
files, but when it came time for an upgrade to support more modern features that were necessary (like dynamic linking for example) a change was made to the ELF format. ELF 
files come in the formats mentioned previously (that being executable, loadable, and linkable) and depending on these formats they will exclude or include certain information
that can be present in ELF files. Depending whether an ELF file is going through a linker or a loader it will be viewed differently, if a ELF file is going through a linker
it will be viewed in terms of sections where sections contained organized information about the file like executable code, read/write data, read only data, symbol tables,
string tables, ext, if the ELF file is going through a loader it will be viewed in terms of segments where segments contain multiple sections (segments are a superset of
sections). An example of this would be there being a segment that is only meant for read only object code and that segment contains multiple sections (the executable code
and the read only data for example). Next we will talk about the 3 main headers inside ELF files, the ELF header, the section header, and the program header (section header).

The ELF header contains general information about the ELF, stuff like the byte order of the file, the size of the address space of the file, respective ISA the file is for,
a magic number (used as an identifier for ELF files), and also information about the section and program header (things like their total size and the size of each entry inside
of the program and section headers). The advantage that ELF files have over other object file formats is that they work regardless of byte order of the architecture (little
or big endian), if the byte order of the ELF file does not match the byte order of the architecture its easy to have a program read the byte order of the file and swap it.

The section header is a part of the ELF file that contains informations about the sections of the file (the header tables aren't considered sections so they don't have an
entry in the section header), each entry in the section header contains the following information, the section name (is an offset into the string table such that the name
is located at the base address of the string table added with this offset), the section type (will talk about the different section types later), flag bits, base address if
its loadable into memory if not just 0, the position of the section in the file, size of section, and more. As mentioned previously each section can have different types
the types come as follows...

PROGBITS: program contents, stuff like executable code and data and debugging info

NOBITS: program contents except no space in the file is allocated for this section (so size of this section is just 0), an example of this would be .bss (also called the
uninitialized data, since uninitialized data is just 0 there is no need to allocate space inside the file for this)

SYMTAB and DYMTAB: contains symbols information, DYMTAB contains symbols that are meant to be dynamically linked during runtime while SYMTAB just contains the rest (or
just symbols that are meant for the regular linker)

STRTAB: just a table that contains strings for symbol names and the such







ELF HEADER

SECTION HEADER

PROGRAM HEADER (SEGMENT HEADER)

(note when the loader loads a program it first loads in the the LOAD type segments inside the elf file, then it uses the INTERP section to load in the required functions from
the dynamic linker)








