- jiffies is a variable in the linux kernel that contains the amount of clock ticks since system boot up (note a clock tick is ...)

- HZ is a macro in the linux kernel that contains the amount of timer interrupts that will occur in a second (aka the clock ticks)

- cpus usually contain a specific register for counting the total amount of cycles since startup called TSC (TimeStamp Counter), in x86 you can find out the value in these registers by calling rdtsc, rdtscl, or rdtscll which will fetch the values in this register for the C language, a more platform independent function for this is the get_cycles function which will fetch this value regardless of architecture (and if this register DNE for this cpu a value of 0 will be returned), comparing the return value for this register on x86 and MIPS MIPS gives a much lower value i assume because the x86 version of the instruction is decoded into microops which are then puts some extra clock cycles inbetween the CISC instructions that read TSC, this is unlike RISC architectures

- to get the current time in kernel space the do_gettimeofday function can help with this, it stores the current time in a timeval struct which contains the time in seconds and and the remaining fractional time in microseconds since epoch, this function also apparently very accurate and even goes as far as asking timing hardware what fraction of a jiffy has occured to get microsecond resolution

- jiffies is initialized to a value on bootup that causes overflow into the most significant 32 bits pretty early on, this is to "help detect problems related to the overflow of this variable"

- /proc/currentime provides a way to get the current time via drivers using the current_kernel_time function in kernel space, this function will get you the full jiffies and the least significant 32 bits of jiffies, and also the current time in using the previously mentioned do_gettimeofday function in seconds since epoch, /proc/uptime also like mentioned in the name extracts uptime and this is done using the jiffies variable aswell

- Note that there is a difference between clock ticks and clock cycles, a clock tick is how long it takes for a timer interrupt to occur in the cpu, these timer interrupts occur at a constant rate and are used to help the cpu to track time and gives programs a method to do so aswell. A clock cycle refers to how long it takes for a high voltage of electricity to arrive at the cpu after the previous voltage.

- Long delays are a method of delaying execution using the jiffies variable and granuality is not needed (don't need precision to the point where the time inbetween each timer interrupt is to long), one method of implementing long delays is just doing a busy loop while waiting for the jiffies to catch up to a specific value for how long you want to wait. The /proc/jitbusy device does this where reading from the device will cause a 1 second delay using long delays inbetween every line read, reading this device without alot of processes active on your system causes the jiffies count to have a difference of 1000 before and after the wait (this is assuming timer interrupt rate is set to 1000 times per second) and the next wait will start immediately on the next jiffy, if you have alot of other processes active then the only change that happens is the time between the next wait will be significantly longer (and not on the next jiffy), and if you enable preemptive kernels the only thing that changes is the difference in jiffy count at the start and after the wait will not be 1000 (so the wait time won't be accurate since the process executing the long delay wait will be have swapped out because of kernel preemption). Another method to implement long delays is to just give the processor up with a schedule() call, this will cause the scheduler to reschedule another process to execute on the CPU, but if the only process that the CPU can schedule is the one you just gave up because a lack of other processes this effectively does nothing and just wastes CPU time by just looping schedule calls and the scheduler reloading the process until the jiffies value is correct, this is unideal since unnecssary execution causes unnecessary temperatures and also unnecessary battery wastage if you're on a laptop, /proc/jitsched implements this long delay and reading this will show inconsistent difference between jiffy values at start and end of waiting since we are rescheduling processes and this only gets worse with more processes on your computer waiting for cpu time. Last method of implementing long delays is just calling wait_event_timeout (which also uses schedule_timeout) or schedule_timeout (and calling set_current_state before) which is just letting the task of doing the delay go to the kernel, this is the best method since schedule_timeout will give up the CPU without rescheduling the current process since we change the state of the process, and times are pretty accurate aswell since schedule_timeout causes a timeout to occur after the delay which will cause the scheduler to place the process back in running