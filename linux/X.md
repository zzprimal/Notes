The linux GUI is made up of 3 parts, a window system, the desktop/window manager, and the desktop environment, these 3 components are what makes up the linux GUI and allows users to do things such as creating processes via clicking, creating windows, closing windows, minimizing, changing sizes, etc

# Window System
A window system is responsible for allocation space for windows and actually drawing the pixels that are shown on windows, think of a window system like the malloc function in the C library for example, malloc is responsible for allocation space for the programmer in main memory just like a Window System is responsible for allocating space for a window to Window Managers, the only difference is that Window Systems provide extra operations that can be performed on the window to Window Managers (though these are very arcaehic operations and is equivalent to coding in assembly, refer to widget toolkits) like drawing operations, minimizing and maximizing, etc. The 2 main Window Systems are the X Window System and the Wayland Window System with the X Window System being created in 1984 and the Wayland Window System being created in 2008. Windowing systems are split into 2 parts, the display server (X servers for X for example), and the clients (X clients for X). The process for how each part interacts with eachother works as follows, a user uses one of it's interfaces whether that be the keyboard or the mouse to interact with the computer, these interactions are then sent to the linux kernel (if its a keyboard interaction a scancode is sent to the linux kernel which is then converted into a keycode) which is then sent to the display server, the display server then sends the interactions that have happened to the necessary clients that are of relevance (relevance here meaning things like a mouse movement on a clients)

# X Window System
X provides the foundational software required for a GUI on linux systems allowing your normal end user to interact with the linux kernel, it does things like drawing windows, allowing processes to be started up via windows, etc. There is a X server (also called the display server) which is responsbile drawing things on the display screen (like windows and your cursor), while the X client give the X server commands telling it what to draw. X provides a framework to X clients to specify to X servers what the client wants the server to draw, the X server also alerts the client when an event happens on its window, examples being keypresses, mouse movements, etc. Heres how a simple communication will work in the X window system, an X client will tell the X server (aka the display server) that it wants to create a window, the X server will then communicate with the window manager asking questions like what the size of the window should be, is it active or inactive (in the foreground or background), is it resizeable, etc. Once that is done the window manager will draw the window itself (it'll use the display server for this task since the window manager is still a client itself, though a special one), it will then pass along to the compositor which will draw special effects onto the window (again using the X server), and then the display server will tell the client that the window is drawn then the client can start drawing onto the window via the display server

# Wayland
Wayland's design is different than X in the fact that the display server, the window manager, and the compositor are all combined into 1 process so the clients only have to communicate with 1 process, this makes wayland less modular but also makes communication faster since you don't have to communicate with a bunch of different processes just to draw a window like you have to do in X. One disadvantage of wayland is that it doesnt have out of the box support for remote rendering unlike X, the task of drawing the contents of the window are given to the client via some library which then stores what it wants to draw in some buffer which then the wayland compositor/display server/window manager takes over from there, since it the client doesn't communicate directly to the wayland compositor but instead stores what it wants to draw in the window on a buffer that has to be on the same machine unfortunately seperating the client and the display server like in X is impossible on wayland without extra support or software.

# Window Manager
A window manager is responsible for managing your windows and how they look, the decorations on the windows (including things like where the close, minimize, expand buttons are), where they pop up when you create one, the initial size of the window, and whether and how you can resize windows. Some window managers include dwm, i3, hyprland, and many more. The window manager is just another client of the display server. You can also not install a preconfigured desktop environment and just a window manager and from there configure your desktop environment to your liking itself adding the things you need  (like a file manager, terminal emulator, status bar, run launcher, etc)

# Desktop Environment
the desktop environment dictates the whole user experience when interacting with your system, whether your system has a taskbar, a search menu to find software, a file explorer, and the desktop environment also includes the window manager as a part of it. A Desktop Environment can be thought of as all the packages that are responsible for the GUI of your desktop, or equivalently just a suite of packages, these packages are very modular and can be swapped out for one another, an example would be the window manager, you can swap out the window manager of a desktop environment with another window manager, or you can get rid of it completely (thought this would take away some key functionality away from your desktop environment so not ideal)

# File Manager
The file manager is the standard gui software that is used to browse the files and folders of your system, in windows you have the file explorer, and on linux you have multiple types of file explorers like dolphin, GNOME files, Thunar, and Nemo are some examples. A file manager isnt really required for a desktop environment since everything a file manager can do can be done from a terminal emulator, but it is a user friendly tool for a user who has no idea how to use a terminal emulator and requires a gui to browse their system.

# Terminal Emulator
The terminal emulator is a piece of software that emulates a terminal which is a text based user interface provided to a user to interact with a computer (meaning the only way for the user to interact with the computer is via a keyboard, and the output of that interaction is given to the user in the form of a screen for example, or going back to the very early days in the form of paper). Some examples are kitty, konsole, and st

# Run Launcher
Is a search launcher for searching and launching applications that is part of your Desktop Environment, some examples are Rofi, and also dmenu

- [X11 vs Wayland](https://youtu.be/nPz5TAGYgzA)
- [What is Wayland](https://youtu.be/g1BoZnekkyM)

Note: to get X11 forwarding working via ssh using machines on different local networks set X11Forwarding on the server to yes in the /etc/ssh/sshd_config file, then on the client set the DISPLAY environment variable to localhost:0.0, then ssh to the server with the -X or -Y flag (on the uni server you have to set the -Y flag for the DISPLAY environment variable to be set on the server), then you can start opening X applications on the server and having them open on the client 

How does X11 forwarding work: the ssh client will first establish a tcp connection with the x11 server, then the ssh server will be listening on a port for x11 clients to establish with and send messages (it is unclear whether or not the ssh server is the one establishing the passive socket since i don't have sudo permissions on the university lab machines, but i assume it is), then communication is done via the x11 client sending it's commands to the ssh server, the ssh server sending the commands to the ssh client, then the ssh client sending it's commands to the x11 server for it to draw, another question is how does the x11 server and client know which port the ssh client and server respectively are listening on, and the answer to this is the DISPLAY environment variable in the form of <hostname>:<display_number>.<screen_number> where host is the ip address of the passive socket and display_number is added to the value 6000 to get the port of the passive socket (i don't think screen_number has any relevance though im not sure), if hostname is not specified it is assumed that the socket for the X server or for the ssh server is a host/unix socket and located at /tmp/.X11-unix/X<display_number> (this is why not specifying localhost for DISPLAY on my machine caused x11 forwarding to fail with the lab machine), more info here https://askubuntu.com/questions/432255/what-is-the-display-environment-variable